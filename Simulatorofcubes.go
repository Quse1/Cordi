/* Симуляция бросков кубиков
Необходимо симулировать броски двух шестигранных кубиков, для этого необходимо реализовать функцию rollDice. Данная функция должна принимать одно целое число, ничего при этом не возвращая.

В функцию будет передаваться число в диапазоне от 2 до 12 включительно (число всегда передается в правильном диапазоне, проверять не нужно), которое будет представлять целевую сумму, которую необходимо получить при бросках кубиков.

Требования
Функция rollDice должна генерировать случайные броски двух кубиков до тех пор, пока сумма значений, выпавших на кубиках, не станет равной переданному в функцию числу.
Результат каждого броска необходимо выводить в консоль.
Когда целевая сумма будет достигнута, программа должна вывести иное сообщение, добавив информацию об общем количестве бросков, которые были сделаны для получения данной суммы.*/

package main

import (
	"fmt"
	"math/rand/v2"
)

func rollDice(n int) {
	var c int
	for {
		dice1 := rand.IntN(6) + 1 // начало бросков с 1 по 6
		dice2 := rand.IntN(6) + 1
		c++
		if dice1+dice2 != n {
			fmt.Printf("Выпало %d и %d, в сумме %d, бросаем еще раз.\n", dice1, dice2, dice1+dice2)
		} else {
			fmt.Printf("Выпало %d и %d, в сумме %d,", dice1, dice2, dice1+dice2)
			switch { // в дипазоне [1, 99]
			case c%10 == 1 && c%100 != 11: // "бросок": Если число оканчивается на 1, но не на 11 (например, 1, 21, 31).
				fmt.Printf(" на это потребовался %d бросок.\n", c)
			case c%10 >= 2 && c%10 <= 4 && (c%100 < 10 || c%100 >= 20): // "броска": Если число оканчивается на 2, 3 или 4, но не на 12, 13 или 14 (например, 2, 3, 4, 22, 23, 24).
				fmt.Printf(" на это потребовалось %d броска.\n", c)
			default: // "бросков": Для всех остальных чисел (например, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14).
				fmt.Printf(" на это потребовалось %d бросков.\n", c)
			}
			break
		}

	}
}

func main() {

	var num int = 6

	rollDice(num)
}
